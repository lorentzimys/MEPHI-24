Лабораторная №2


Цель работы 
Разобраться как работает алгоритм шифрования RSA на практике.
Написать программу, реализующую данный алгоритм

Описание используемого метода
Шифрование производится с помощью алгоритма RSA, являющего первым эффективным асинхронным алгоритмом шифрования, который широко применяется и сегодня.

Постановка задачи
Составить консольную программу, которая генерировала бы данные для приватного и публичного ключей,
которые затем могли бы быть использованы для шифрования и дешифрования текста алгоритмом RSA.
Т.к. алгоритм RSA шифрует числовые данные, текст должен быть предварительно преобразован в числовые данные.
Для этого, при обработке каждого символа входящего текста программа будет получать его код из таблицы символов UTF, 
который впоследствии будет зашифрован с помощью публичного ключа программы.
Для расшифровки зашифрованного сообщения будут производиться обратные операции. Расшифровка сообщения производится с применением приватного ключа.

Алгоритм работы программы
Утилита реализует функционал для работы с шифрованием и дешифрованием текста с использованием алгоритма RSA. Она поддерживает три основные операции:
- Генерация ключей (публичного и приватного).
- Шифрование текста.
- Дешифрование текста.

Алгоритм работы
1. Сбор и обработка аргументов командной строки
Утилита анализирует переданные через process.argv аргументы командной строки.
Обрабатываются два типа аргументов:
Флаги:
-E или --encrypt — шифрование текста.
-D или --decrypt — дешифрование текста.
Аргументы в формате --ключ=значение:
--e и --n — параметры для шифрования (открытый ключ).
--d и --n — параметры для дешифрования (закрытый ключ).

2. Генерация ключей
Если флаги -E или -D отсутствуют, выполняется генерация пары ключей:

Используются два простых числа p и q для вычисления:
n = p * q — модуль.
φ = (p - 1) * (q - 1) — значение функции Эйлера.
Выбирается случайное число e (открытая экспонента), такое что:
1 < e < φ.
e взаимно просто с φ.
Вычисляется d (закрытая экспонента) как мультипликативная инверсия e по модулю φ, с использованием расширенного алгоритма Евклида.
Генерируется пара ключей:
Публичный ключ: {e, n}.
Приватный ключ: {d, n}.

3. Шифрование текста
Если передан флаг -E или --encrypt:

Пользователь вводит текст для шифрования.
Используется метод MyCrypto.encrypt:
Текст разбивается на символы.
Каждый символ преобразуется в числовое значение.
Значение шифруется
Зашифрованные коды объединяются в строку, разделенную пробелами.
Результат выводится в консоль.

4. Дешифрование текста
Если передан флаг -D или --decrypt:

Пользователь вводит зашифрованный текст (последовательность чисел, разделённых пробелами).
Используется метод MyCrypto.decrypt:
Текст разбивается на числа (коды символов).
Каждый код дешифруется
Дешифрованные коды преобразуются в символы и объединяются в строку.
Результат выводится в консоль.


Исходные данные
Вариант №5
p = 223
q = 317

Результаты работы программы:
Программа тестировалась на тексте, состоящем из латинских и киррилических символов: "Привет, Kitty!"

Генерация ключей:
node .\lab2.js 
privateKey: {"d":18917,"n":70691}, publicKey: {"e":44093,"n":70691}

Шифрование:
node .\lab2.js  -E --e=44093 --n=70691
Введите текст для шифрования:
Привет, Kitty!
Зашифрованный текст:
5700 44036 4318 19798 38086 11631 59654 47960 29092 49398 39643 39643 21473 49523

Дешифрование:
node .\lab2.js -D --d=18917 --n=70691
Введите текст для дешифрования:
5700 44036 4318 19798 38086 11631 59654 47960 29092 49398 39643 39643 21473 49523
Дешифрованный текст:
Привет, Kitty!


Анализ результатов:
В результат выполнения программы получилось зашифровать и расшифровать текст, состоящий из символов разных алфавитов с помощью алгоритма RSA.
По сравнению с методами подстановки и перестановки, которые использовались в первой лабораторной работе, шифрование с помощью алгоритма RSA можно использовать в реальных задачах криптографии.
Данный алгоритм все еще достаточно прост в реализации, при этом обеспечивает достаточно высокий уровень надежности. При этом длина сгенерированных ключей должны быть существенно выше тех, которые генерируются в рамках практической работы.
Из минусов данного алгоритма можно отметить то, что зашифрованный текст будет существенно превышать исходных в объеме, так как для шифрования каждого символа требуется преобразование его в число из таблицы UTF.
Данный алгоритм будет значительно медленнее симметричных алгоритмов шифрования, так как требуется большое количество операций с большими числами. Шифрование длинного текста может занять большое количество времени.


Выводы
В резуьтате написания программы удалось разобраться и закрепить на практике алгоритм шифрования RSA - один из классических ассиметричных алгоритмов шифрования. Благодаря выполнению практической работы стало гораздо понятнее как работает ассиметричное шифрование.
В процессе выполнения работы возникали некоторые ошибки, которые приходилось решать. Например, сначала была некорректно подсчитана переменная d, которая имела дробное значение, что было в корне неверно, т.к. её значение не может быть дробным.
Так же возникали проблемы с преобразованием чисел в языке javascript. JS - не самый подходящий язык для криптографических операций в силу многих нюансов, возникающих в процессе работы с числами и преобразованием Number в BitInt.
Для реализации данного алгоритма, с учетом его минусов, лучше использовать более низкоуровневый и быстрый язык программирования.